using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace GAE.Generators;

[Generator]
public sealed class ArcadeDiscoveryGenerator : IIncrementalGenerator
{
    private const string ArcadeGameAttributeFullName = "GAE.Shared.Core.ArcadeGameAttribute";
    private const string ArcadeGameInterfaceFullyQualifiedName = "global::GAE.Shared.Core.IArcadeGame";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var gameCandidates = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                ArcadeGameAttributeFullName,
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => ExtractGameInfo(ctx))
            .Where(static info => info is not null)
            .Select(static (info, _) => info!);

        context.RegisterSourceOutput(
            gameCandidates.Collect(),
            static (spc, games) => EmitRegistrySource(spc, games));
    }

    private static GameInfo? ExtractGameInfo(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not INamedTypeSymbol classSymbol)
        {
            return null;
        }

        bool implementsArcadeGame = classSymbol.AllInterfaces
            .Any(static i => i.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == ArcadeGameInterfaceFullyQualifiedName);

        bool hasValidConstructor = classSymbol.InstanceConstructors
            .Any(static ctor => ctor.Parameters.Length == 0
                             && ctor.DeclaredAccessibility == Accessibility.Public);

        return new GameInfo(
            fullTypeName: classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            displayName: classSymbol.Name,
            implementsArcadeGame: implementsArcadeGame,
            hasValidConstructor: hasValidConstructor,
            location: classSymbol.Locations.FirstOrDefault());
    }

    private static void EmitRegistrySource(SourceProductionContext context, ImmutableArray<GameInfo> games)
    {
        foreach (GameInfo game in games.Where(static game => !game.ImplementsArcadeGame))
        {
            context.ReportDiagnostic(Diagnostic.Create(
                DiagnosticDescriptors.MissingInterfaceRule,
                game.Location,
                game.DisplayName));
        }

        foreach (GameInfo game in games.Where(static game => game.ImplementsArcadeGame && !game.HasValidConstructor))
        {
            context.ReportDiagnostic(Diagnostic.Create(
                DiagnosticDescriptors.MissingParameterlessConstructorRule,
                game.Location,
                game.DisplayName));
        }

        var validGames = games
            .Where(static game => game.ImplementsArcadeGame && game.HasValidConstructor)
            .OrderBy(static game => game.DisplayName)
            .ToList();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();
        sb.AppendLine("namespace GAE.Generated");
        sb.AppendLine("{");
        sb.AppendLine("    public static class GameRegistry");
        sb.AppendLine("    {");
        sb.AppendLine("        public static IReadOnlyList<GAE.Shared.Core.IArcadeGame> CreateAll()");
        sb.AppendLine("        {");
        sb.AppendLine("            return new GAE.Shared.Core.IArcadeGame[]");
        sb.AppendLine("            {");

        foreach (GameInfo game in validGames)
        {
            sb.AppendLine($"                new {game.FullTypeName}(),");
        }

        sb.AppendLine("            };");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static class GameTelemetry");
        sb.AppendLine("    {");
        sb.AppendLine($"        public static int TotalGamesDiscovered => {validGames.Count};");
        sb.AppendLine();
        sb.AppendLine("        public static string[] GameNames => new string[]");
        sb.AppendLine("        {");

        foreach (GameInfo game in validGames)
        {
            sb.AppendLine($"            \"{game.DisplayName}\",");
        }

        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource("GameRegistry.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }
}
