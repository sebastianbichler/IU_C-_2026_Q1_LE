### Programmieren mit C# (DSPC016)

---

F√ºr Gruppe 5 ist das Thema **‚ÄûMetaprogrammierung & Source Generators‚Äú** der absolute technologische Vorreiter. W√§hrend Gruppe 3 (Reflection) zur Laufzeit nach Plugins sucht, sorgt Gruppe 5 daf√ºr, dass der Hub bereits beim Kompilieren "wei√ü", welche Spiele fest im System verbaut sind.

Euer Ziel ist es, den **"Zero-Overhead-Boilerplate"** zu realisieren. Niemand soll manuell Code schreiben m√ºssen, um ein neues Spiel im System anzumelden.

---

### 1. Theoretisches Konzept (10 Min)

Gruppe 5 arbeitet nicht *im* Programm, sondern *am* Compiler.

- **Statische Analyse:** Ihr lest den Quellcode der anderen Gruppen, noch bevor er ausgef√ºhrt wird.

- **Code-Emission:** Ihr schreibt zus√§tzliche C#-Dateien "on the fly".

- **Wissenschaftlicher Bezug:** Vergleich von Runtime-Kosten (Reflection) vs. Compile-time-Kosten. Warum sind Source Generators f√ºr Mobile/AOT (Ahead-of-Time) so wichtig?

---

### 2. Praktische Umsetzung: Der Auto-Registrator (40 Min)

Die Gruppe baut einen `IIncrementalGenerator`. Dieser sucht nach Klassen, die das `[ArcadeGame]`-Attribut tragen, und generiert eine zentrale Registrierungsmethode.

**C#-Beispiel f√ºr Gruppe 5 (The Generator Skeleton):**

C#

```
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace GAE.Generators;

[Generator]
public class GameRegistryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. Suche nach Klassen-Syntax mit Attributen
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => node is Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax,
                transform: (ctx, _) => ctx.Node as Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax)
            .Where(c => c is not null);

        // 2. Generiere den Code
        context.RegisterSourceOutput(classDeclarations.Collect(), (spc, classes) =>
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using GAE.Core;");
            sb.AppendLine("namespace GAE.Generated;");
            sb.AppendLine("public static class AutoRegistration {");
            sb.AppendLine("    public static void RegisterAll() {");

            foreach (var cls in classes)
            {
                // Hier generieren wir den Aufruf f√ºr jedes gefundene Spiel
                sb.AppendLine($"        GameRegistry.Instance.Register(new {cls.Identifier.Text}());");
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");
            spc.AddSource("AutoRegistration.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        });
    }
}
```

---

### 3. Die ‚ÄûWissenschaftliche‚Äú Komponente: Roslyn & AST

Gruppe 5 soll untersuchen, was ein **Abstract Syntax Tree (AST)** ist.

- **Aufgabe:** Schaut euch den Code der anderen Gruppen an. Wie unterscheidet der Compiler zwischen einer Klasse, die nur zuf√§llig so hei√üt, und einer echten Spiel-Klasse (Semantisches Modell)?

- **Experiment:** Versucht, im Generator eine Warnung (Diagnostic) auszugeben, wenn ein Spiel das `[ArcadeGame]`-Attribut nutzt, aber *nicht* von `IArcadeGame` (Gruppe 1) erbt.

---

### 4. Aufgaben f√ºr die heutige Reststunde (Interaktiv)

1. **Projekt-Setup:** Erstellt ein `netstandard2.0` Projekt f√ºr den Generator (Voraussetzung f√ºr Roslyn).

2. **Referenzierung:** Helft den anderen Gruppen, die `.csproj`-Datei so anzupassen, dass der Generator als `OutputItemType="Analyzer"` eingebunden wird.

3. **Erster Test:** Generiert eine einfache `public static string GeneratorInfo = "Version 1.0";` Datei und pr√ºft, ob Gruppe 4 (Dashboard) darauf zugreifen kann.

---

### Verkn√ºpfung im Game-Hub:

Gruppe 5 ist der **Automatisierer**. Ihr nehmt Gruppe 4 die Arbeit ab, die Spiele-Liste manuell zu pflegen. Sobald Gruppe 1 oder ein Student ein neues Spiel programmiert, "erfindet" euer Generator den passenden Registrierungscode dazu.

---

## üèÅ Abschluss f√ºr heute (f√ºr alle Gruppen)

In den letzten 5 Minuten der Stunde:

1. **Gruppe 1** checkt das Interface `IArcadeGame` ein.

2. **Alle Gruppen** stellen sicher, dass ihr Projekt gegen dieses Interface kompiliert.

3. **Ziel f√ºr morgen:** Der Hub (Gruppe 4) startet, l√§dt via Source Generator (Gruppe 5) ein Dummy-Spiel, das via Reflection (Gruppe 3) validiert wurde und dessen Highscores via LINQ (Gruppe 2) filterbar sind.



---


