Dieser Teil der Vorlesung ist darauf ausgelegt, den Studierenden zu zeigen, wie man Boilerplate-Code (wiederkehrenden
Code) komplett eliminiert und die Performance zur Kompilierzeit optimiert.

---

# Vorlesungsteil: Incremental Source Generators (Deep Dive)

**Kontext:** Automatisierung der Spiele-Registrierung im GAE.

## 1. Die Theorie: Warum "Incremental"?

Frühere Source Generators (C# 9) mussten bei jeder kleinsten Änderung im Editor (selbst bei einem Tippfehler) den
kompletten Code neu analysieren. Das hat die IDE extrem verlangsamt.

**Das Prinzip der Pipeline:**
Ein `IIncrementalGenerator` arbeitet wie eine moderne Daten-Pipeline (ähnlich wie LINQ):

1. **Selection:** Wir wählen nur die Syntax-Knoten aus, die uns interessieren (z.B. Klassen mit einem bestimmten
   Attribut).
2. **Transformation:** Wir wandeln diese Knoten in einfache Datenmodelle (POCOs) um.
3. **Caching:** Roslyn vergleicht diese Modelle. Wenn sie sich nicht geändert haben, wird der nachfolgende
   Generator-Schritt übersprungen.
4. **Generation:** Nur wenn nötig, wird der neue Quellcode generiert.

---

## 2. Das Live-Demo Projekt: "GAE Game Provider"

**Szenario:** Wir wollen nicht mehr manuell `new Snake()`, `new PacMan()` etc. in eine Liste schreiben. Wir wollen, dass
jede Klasse, die das Attribut `[ArcadeGame]` hat, automatisch in einer zentralen Liste auftaucht.

### Schritt A: Die Projektstruktur

Ein Source Generator muss in einem eigenen Projekt liegen, das `netstandard2.0` als
Ziel hat (Voraussetzung für den Compiler).

### Schritt B: Der Code des Generators

Kopieren Sie diesen Code in Ihr Demo-Projekt (`GAE.Generators`):

```csharp
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;

[Generator]
public class GameRegistryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. Suche nach Klassen mit dem Attribut "ArcadeGame"
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => node is Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax,
                transform: (ctx, _) => ctx.Node as Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax)
            .Where(m => m is not null);

        // 2. Den Code generieren
        context.RegisterSourceOutput(provider.Collect(), (spc, classes) =>
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("namespace GAE.Generated;");
            sb.AppendLine("public static class GameRegistry {");
            sb.AppendLine("    public static void Load() {");

            foreach (var cls in classes)
            {
                sb.AppendLine($"        System.Console.WriteLine(\"Lade Spiel: {cls.Identifier.Text}\");");
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            spc.AddSource("GameRegistry.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        });
    }
}

```

---

## 3. Übung

**Aufgabe: "The Factory Generator" (60 Min)**
Schreiben Sie einen Generator, der nicht nur den Namen ausgibt, sondern eine echte **Factory-Klasse
** erstellt.

* Wenn eine Klasse `[ArcadeGame]` hat, soll eine Methode `public IArcadeGame Create[Name]()` generiert werden.

### 💡 Musterlösung

```csharp
// Generierter Code sollte so aussehen:
public class GameFactory {
    public IArcadeGame CreateSnake() => new Snake();
    public IArcadeGame CreatePacMan() => new PacMan();
}

```

**Wichtiger Hinweis für die Lösung:** Die Studierenden müssen darauf achten, dass die Zielklassen einen parameterlosen
Konstruktor haben – ein schönes Thema für die Diskussion über "Constraints".

---

## 4. Hintergrundwissen für den Dozenten (Bezug Kotz/Wenz)

* **Reflection vs. Generator:** Laut **Kotz/Wenz (Kap. 14)** ist Reflection mächtig, aber "blind" zur Kompilierzeit.
  Zeigen Sie den Studierenden in Visual Studio, dass der generierte Code von Source Generators **IntelliSense** hat! Man
  kann "F12" (Go to Definition) auf der generierten Methode drücken. Das ist ein riesiger Vorteil für die Wartbarkeit.
* **AOT (Ahead-of-Time) Compilation:** Erwähnen Sie, dass Reflection in modernen .NET-Umgebungen (wie WebAssembly oder
  mobilen Apps) oft Probleme macht. Source Generators sind die Lösung, da der Code bereits existiert, bevor die App
  startet.
* **Debugging:** Ein Source Generator ist schwer zu debuggen. Tipp: Nutzen Sie `Debugger.Launch()` im Code oder (besser)
  Unit Tests für den Generator mit dem Paket `Microsoft.CodeAnalysis.CSharp.Analyzer.Testing`.

---

## 5. Vorlesungs-Abschluss: Wann nutze ich was?

Geben Sie den Studierenden dieses Entscheidungs-Diagramm mit:

| Kriterium        | Reflection                        | Source Generators                     |
|------------------|-----------------------------------|---------------------------------------|
| **Zeitpunkt**    | Zur Laufzeit (Runtime)            | Zur Kompilierzeit (Build)             |
| **Performance**  | Langsamer (Overhead)              | Maximal (wie handgeschriebener Code)  |
| **Flexibilität** | Hoch (kann unbekannte DLLs laden) | Mittel (muss beim Build bekannt sein) |
| **Anwendung**    | Plug-ins, externe Add-ons         | Boilerplate, Mapping, API-Clients     |

---

Hier ist das versprochene **„Roslyn Cheat-Sheet“**. Dieses Dokument ist Gold wert für die Studierenden, da die Arbeit
mit dem Syntaxbaum anfangs oft frustrierend ist („Wo finde ich den Namen?“, „Wie komme ich an das Attribut?“).

---
