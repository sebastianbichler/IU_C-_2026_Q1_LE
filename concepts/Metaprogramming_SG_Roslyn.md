# Roslyn Syntax Cheat-Sheet für Source Generators

**Thema:** Den C#-Code verstehen und navigieren

### 1. Die wichtigsten Syntax-Knoten (Struktur)

Wenn du den Code scannst, suchst du meistens nach diesen Objekten:

* **`ClassDeclarationSyntax`**: Repräsentiert eine Klassen-Definition.
* `.Identifier.Text`: Der Name der Klasse (z.B. `"Snake"`).
* `.Modifiers`: Liste der Modifizierer (z.B. `public`, `partial`).


* **`MethodDeclarationSyntax`**: Eine Methode innerhalb einer Klasse.
* `.ReturnType`: Der Rückgabetyp.
* `.ParameterList`: Die Liste der Argumente.


* **`AttributeSyntax`**: Ein Attribut über einem Element (z.B. `[ArcadeGame]`).
* `.Name`: Der Name des Attributs.


* **`NamespaceDeclarationSyntax`**: Der Namespace, in dem die Klasse liegt.

---

### 2. Der Weg zum Ziel: Häufige Aufgaben

#### A. Prüfen, ob eine Klasse ein bestimmtes Attribut hat

Im `predicate` des Incremental Generators nutzt du oft diesen Check:

```csharp
// Einfacher Check auf den Namen des Attributs
classDeclaration.AttributeLists
    .SelectMany(al => al.Attributes)
    .Any(a => a.Name.ToString() == "ArcadeGame")

```

#### B. Den vollqualifizierten Namen (Full Name) erhalten

Nur der `Identifier` liefert nur `"Snake"`. Für den Generator brauchst du oft `GAE.Games.Snake`. Dafür brauchst du das *
*SemanticModel**:

```csharp
// Im Transform-Schritt des Generators
var symbol = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
string fullName = symbol.ToDisplayString(); // Ergebnis: "GAE.Games.Snake"

```

---

### 3. Semantic Model: „Wissen“ statt nur „Sehen“

Während der **Syntaxbaum** nur Text-Strukturen sieht, weiß das **SemanticModel** alles über die Logik:

* **`INamedTypeSymbol`**: Das semantische Gegenstück zur Klasse.
* `.BaseType`: Von welcher Klasse stammt sie ab?
* `.AllInterfaces`: Welche Interfaces werden implementiert? (Wichtig für die Übung: „Implementiert die Klasse
  `IArcadeGame`?“)
* `.GetMembers()`: Liste aller Methoden und Felder.

---

### 4. Code-Generierung (Best Practices)

Source Generators nutzen meistens den `StringBuilder`, um den neuen Code zu „schreiben“.

* **File-Header:** Starte immer mit `// <auto-generated />`. Das sagt der IDE und anderen Tools, dass sie diesen Code
  nicht manuell bearbeiten sollen.
* **Partial Classes:** Generiere Code fast immer als `partial`, damit der handgeschriebene Teil der Klasse und dein
  generierter Teil verschmelzen können.
* **Namespace:** Nutze `namespace DeinNamespace;` (File-scoped namespaces), um geschweifte Klammern zu sparen.

---

### 💡 Profi-Tipp für die Übung: Der „Syntax Visualizer“

Sag deinen Studierenden, dass sie in Visual Studio unter **View -> Other Windows -> Syntax Visualizer** ein Tool finden,
das ihnen live zeigt, welcher Code-Schnipsel welchem Syntax-Knoten entspricht. Das spart Stunden an Sucharbeit!

---

### Zusammenfassung für die Vorlesung:

Mit diesem Cheat-Sheet bewaffnet, sollten die Studierenden in der Lage sein, die **Factory-Aufgabe** zu lösen.

**Hinweise zum Ablauf der Übung:**

1. **Suchen:** Alle `ClassDeclarationSyntax` finden.
2. **Filtern:** Hat sie das `[ArcadeGame]` Attribut?
3. **Analysieren:** Wie heißt die Klasse? In welchem Namespace liegt sie?
4. **Generieren:** Den String für `public IArcadeGame Create...() => new ...();` zusammenbauen.
